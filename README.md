# Iron Router

A reactive, highly customizable router that is Meteor specific -- it knows about
your subscriptions, data sources and helps you take care of common problems.


## Installation

Iron Router can be installed with
[Meteorite](https://github.com/oortcloud/meteorite/). From inside a
Meteorite-managed app:

```sh
$ mrt add iron-router
```

Note that Iron Router requires Meteor >= 0.6.5

## API

### Basics

By default, Iron Router takes over rendering the body of the page. To tell it
what to render, you provide a *route map*, which is a list of route names and
options:

```javascript
Router.map(function() { 
  this.route('home', {path: '/'});
  this.route('aboutUs'); 
  this.route('postEdit', {path: 'posts/:id/edit'});
});
```
```coffee
Router.map ->
  @route 'home', path: '/'
  @route 'about'
  @route 'postEdit', path: '/posts/:id/edit'
```

By default the *name* of the route (the first argument to `this.route`) is also
the name of the template to be rendered by this route. So for the code above to
work, you would need a template named `home` and a template named `aboutUs`.
Similarly, by default the route is rendered at `/<name>`, but you can see above,
that you can override this with the `path` option.


### Options

#### Basic
 - `path`  defaults to the route name
 - `template`  defaults to the route name

#### Extended
 - `layout` defaults to simply {{{yield}}} within `<body>` tags
 - `data` collection and other data items reference
 - `waitOn` specificies collection which must be loaded before render
 - `loadingTemplate` template to render while loading
 - `notFoundTemplate` template to render if item is not in collection


### Layouts

A *layout* is simply a template which specifies one or more *yields* which the
router can render templates into.  For example, the following layout has two
named yields (`sidebar` and `footer`) in addition to the main yield.

```handlebars 
<template name="layout"> 
  <aside>
    <!-- render to the sidebar yield -->
    {{{yield 'sidebar'}}}
  </aside>

  <nav>
    <ul>
      <!-- static content here like nav links -->
    </ul>
  </nav>

  <!-- the main template will be rendered within triple brakcet here -->
  {{{yield}}}

  <footer>
    <!-- render to the footer yield -->
    {{{yield 'footer'}}}
  </footer>
</template>
```
The content for the yield 'sidebar' handlebars helpers would for example be generated by a specific template through a contentFor helper.

```handlebars
<template name ="postShow">
  {{#contentFor 'sidebar'}}
   <aside>
     <h3>This is the sidebar for the post title: {{title}}</h3>
   </aside>
  {{/contentFor}}
  
  <div class="container">
    <h2>This is in the main yield</h2>
    <!-- etc... -->
  </div>
</template>
```

The layout enables a route to render multiple templates in addition to the main
template. You don't have to use a layout: if none is specified, the router just
uses a default layout which contains only the main yield and no other named
yields.

For more information about configuring the layout, see the configuration section
below. Named yields can be configured globally, but also at the the controller
level.

### Helpers

#### Path Helper
A *path helper* is a handlebard helper which calls a router path function which generates the path.

```handlebars
  <a href="{{pathFor 'postEdit'}}">Edit Post</a>
```
Where the post data object has an {id: 555} and the route is defined:
```javascript
  this.route('postEdit', {path: 'posts/:id/edit'});
```
The html will be replaced with

```html
  <a href="/posts/555/edit">
```

#### URL Helper

A *URL helper* is a handlebard helper which calls a router url function which generates a complete url.

```handlebars
  <img src="{{urlFor 'amazonS3image'}}">
```

### Hooks
Before and after hooks may be passed to a RouteController when it is instantiated and the hooks will be execute before and after the controller action is run.


### Configuration

Configuration of Iron Router is hierarchical: settings flow from the Router
to routes and finally to route controllers.

### Global

To set up a general layout for the router, you do something like the following.
This will render the template with the name `sidebar` to all yields named
`sidebar` and so on for `footer`, using the template called `layout`.


```javascript
Router.configure({
  layout: 'layout',
  renderTemplates: { 
    /* render the templated named footer to the 'footer' yield */
    'footer': { to: 'footer' },

    /* render the template named sidebar to the 'sidebar' yield */
    'sidebar': { to: 'sidebar' }
  },
  loadingTemplate: 'loading',
  notFoundTemplate: 'notFound'
});
```

### Routes

### Controllers

All routes are handled by a RouteController.

Route controller are created in four different ways:

###Explicit Handler

If a handler is described explicitly by a route e.g.

```javascript
this.route('postShow', {
  path: 'posts/:slug',
  handler: function () {
    this.render ({ template: 'postShow'});
    },
    //...
```
The Router will create a new RouteController where the controller action is the handler.

###Named Controller

If a controller is described by a route, e.g.
```javascript
this.route('postExplode', {
  path: '/explode/:slug',
  controller: specificName,
  //...
```
the specifically named controller or a new controllerClass created with the name will be used.

###Automatically Discovered Controller

If neither a handler nor a controller is not named, e.g.

```javascript
this.route('feed', {
  path: '/feed'
  });
```
then the router will search the namespace for 'feedController', i.e. name+'Controller' and create a new  matching controller Object.

###default controller

If you haven't created a RouteController for a route, one will be created automatically (anonymously) when the route is run.

#### Controller fields
Controllers also include other commonly used functional field which are called on common events: 
```javascript
PostController = Router.Controller.extend({
  include: Form, //allow mixin functionality from other objects
  waitOn: Subscriptions.posts, //will render 'loading' template while loading
  onRendered: function () { 
    $('.blinkingpost').blink(); //will execute e.g. jquery function onRender
    }, 
  onFirstRendered: function () {
    // only executed the first time the template is rendered
    },
  onReactiveRendered: function () {
    // executed when a data invalidation triggers a reactive rendering
    },

```    
#### Server Side Routing
Server side routing is enabled by setting the `where` paramer to server on the route, e.g.
```javascript
this.route('api', {
  path: '/api/:verb'
  where: 'server'
  // ...
```  

## Coffeescript Support

Iron router has very good support for coffeescript. The inheritance model for
RouteControllers is the same as that of Coffeescript itself, so you can define
new controllers in a very intuitive way:

```coffeescript class @PostController extends RouteController template: 'post'

    renderTemplates: 'sidebar': to: 'sidebar' 'footer': to: 'footer'

    data: -> title: 'Hello World'

    run: -> console.log 'running' super ```

The above controller is created in the global namespace with the use of `@`, and
will be automatically used to render the route called `/post`.

## Examples

- Basic example in CoffeeScript:
  https://github.com/cmather/iron-router-coffeescript-example

## Contributing
